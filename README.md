[![latest](https://img.shields.io/badge/release-v1.1.2-00DD00)](https://github.com/BOTCLibs/BrgOfTheCyber_RTC/releases/latest)
[![Foo](https://img.shields.io/badge/%E2%82%BD%24%E2%82%AC%20%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D1%82%D1%8C-%D0%90%D0%B2%D1%82%D0%BE%D1%80%D0%B0-blue.svg?style=flat-square)](https://new.donatepay.ru/@m0ll1s)
[![Foo](https://img.shields.io/badge/README-ENGLISH-blueviolet.svg?style=flat-square)]()  


# BrgOfTheCyber_RTC
Библиотека для работы с микросхемой реального времени (RTC) DS3231
- Время считается на базе millis()
- Есть форматирование в строки (DD/MM/YYYY)
- Эффект тикания на вывод LCD и др. (00:00 00 00)

### Совместимость
Совместима со всеми Arduino платформами.

### Зависимости
- Wire (для внешних RTC)
- EEPROM (для сохранения состояния внутренних часов)

## Содержание
- [Использование](#usage)
- [Версии](#versions)
- [Установка](#install)
- [Баги и обратная связь](#feedback)

<a id="usage"></a>

## Использование
### Функции запроса
Обработка запроса на RTC и вывод его времени:

```cpp
// Установка времени в ручную
void setDateTime(uint16_t year, uint8_t month, uint8_t day,
                     uint8_t hour, uint8_t minute, uint8_t second);

// Установить время из времени компиляции
void setDateTimeFromCompileTime(); 

// Выводит: Год, Пример: 2025
uint16_t getYear();

// Выводит: Месяц, Пример: 1
uint8_t getMonth();

// Выводит: День, Пример: 1
uint8_t getDay();

// Выводит: Час, Пример: 1
uint8_t getHour();

// Выводит: Минуту, Пример: 1
uint8_t getMinute();

// Выводит: Секунду, Пример: 1
uint8_t getSecond();

// Выводит: День недели, Пример: 1 (1=воскресенье)
uint8_t getWeekday();

// Только для внутренних часов
void adjustTime(long adjustment_ms); // Корректировка внутренних часов
    
// Только для внешних RTC
float getTemperature(); // Получить температуру (только для DS3231)
bool lostPower(); // Проверка потери питания (только для внешних RTC)
    
// Общие функции
bool isRunning(); // Проверка, работают ли часы
```

### Форматированный вывод

```cpp
// Выводит: Час и Минуту, Пример: 00:01 (00 01) - Эффект тикания.
String getTime(bool tickingEffect = false); 

// Выводит: День, Месяц, Пример: 01/01
String getToDay();

// Выводит: День, Месяц, Год, Пример: 01/01/2025
String getDate();

// Выводит: День, Месяц, Год, Час, Минуту, Секунду, Пример: 01/01/2025 00:00:00
String getDateTime();

// Выводит: День недели, Пример: Sunday
String getWeekdayString(); 
```

### Алгоритм Зеллера
Алгоритм, разработанный Кристианом Зеллером, для вычисления дня недели для любой календарной даты. Работает для григорианского и юлианского календарей.

```cpp
uint16_t y = _currentTime.year;
uint8_t m = _currentTime.month;
uint8_t d = _currentTime.day;
  
if (m < 3) {
  m += 12;
  y--;
}
  
uint16_t century = y / 100;
y %= 100;
  
uint8_t weekday = (d + (13 * (m + 1)) / 5 + y + y / 4 + century / 4 + 5 * century) % 7;
```

### BrgOfTheCyber_RTC
Инициализация библиотеки и установка режима RTC:

```cpp
// Для внутренних часов
#include <BrgOfTheCyber_RTC_Sys.h>
BrgOfTheCyber_RTC_Sys rtc;

rtc.begin(); // Инициализация
    
// Для внешних RTC модулей
#include <BrgOfTheCyber_RTC.h>
BrgOfTheCyber_RTC rtc(RTC_DS1307);
BrgOfTheCyber_RTC rtc(RTC_DS3231);
BrgOfTheCyber_RTC rtc(RTC_PCF8563, 0x51);
    
rtc.begin(); // Инициализация
```

## Примеры
### BOTC_RTC_DS1307

```cpp
#include <BrgOfTheCyber_RTC.h>                          // Подключаем библиотеку для работы с внешними RTC модулями.
BrgOfTheCyber_RTC rtc(RTC_DS1307);                      // Инициализация объекта для модуля DS1307.

void setup() {
  Serial.begin(9600);                                   // Инициализирует последовательное соединение и задаём скорость передачи данных.
  delay(1000);                                          // Задержка 1000ms (1s)
  
  Serial.println("Демонстрация работы модуля DS1307:");
  
  if (!rtc.begin()) {                                   // Инициализация модуля DS1307, если модуль не найден.
    Serial.println("Ошибка: DS1307 не найден!");        // Вывод сообщения "Ошибка: DS1307 не найден!".
    while(1);                                           // Бесконечный цикл при ошибке.
  }
  
  Serial.println("Модуль DS1307 подключен!");           // Сообщение об успешном подключении.
  
  rtc.setDateTime(2025, 1, 1, 0, 0, 0);                 // Установите время один раз, затем закомментируйте.
}

void loop() {
  static uint32_t Timer = 0;                            // Объявление локальной переменной. (таймер-1)
  
  if (millis() - Timer >= 1000) {                       // Если отсчитанное время >= 1000 ms, тогда:
    Timer = millis();                                   // Сброс таймера-1.
    
    Serial.print("Дата и время: ");                     // Вывод сообщения "Дата и время"
    Serial.print(rtc.getDateTime());                    // Получаем и отправляем информацию о Дате и Времени. Пример: 01/01/2025 00:00:00
    
    Serial.print(" | Время с тиканием: ");              // Вывод сообщения " | Время с тиканием: "
    Serial.println(rtc.getTime(true));                  // Получаем и отправляем информацию Времени. Пример: 00:00 (00 00)
    
    static uint8_t Timer2 = 0;                          // Объявление локальной переменной. (таймер-2)
    if (++Timer2 >= 10) {                               // Каждые 10 секунд отправляем подробную информацию.
      Timer2 = 0;                                       // Сброс таймера-2.
      
      Serial.print("Подробно: Год=");                   // Вывод сообщения "Подробно: Год="
      Serial.print(rtc.getYear());                      // Получаем и отправляем информацию "Год". Пример: 2025
      Serial.print(" Месяц=");                          // Вывод сообщения " Месяц="
      Serial.print(rtc.getMonth());                     // Получаем и отправляем информацию "Месяц". Пример: 1
      Serial.print(" День=");                           // Вывод сообщения " День="
      Serial.print(rtc.getDay());                       // Получаем и отправляем информацию "День". Пример: 1
      Serial.print(" Час=");                            // Вывод сообщения " Час="
      Serial.print(rtc.getHour());                      // Получаем и отправляем информацию "Час". Пример: 0
      Serial.print(" Минута=");                         // Вывод сообщения " Минута="
      Serial.print(rtc.getMinute());                    // Получаем и отправляем информацию "Минута". Пример: 0
      Serial.print(" Секунда=");                        // Вывод сообщения " Секунда="
      Serial.println(rtc.getSecond());                  // Получаем и отправляем информацию "Секунда". Пример: 0

      Serial.print("Формат ДД/ММ: ");                   // Вывод сообщения "Формат ДД/ММ: "
      Serial.print(rtc.getToDay());                     // Получаем и отправляем информацию в формате День/Месяц. Пример: 01/01
      Serial.print(" | Формат ДД/ММ/ГГГГ: ");           // Вывод сообщения " | Формат ДД/ММ/ГГГГ: "
      Serial.println(rtc.getDate());                    // Получаем и отправляем информацию в формате День/Месяц/Год. Пример: 01/01/2025
    }
  }
}
```

### BOTC_RTC_DS3231

```cpp
#include <BrgOfTheCyber_RTC.h>                          // Подключаем библиотеку для работы с внешними RTC модулями.
BrgOfTheCyber_RTC rtc(RTC_DS3231);                      // Инициализация объекта для модуля DS3231.

void setup() {
  Serial.begin(9600);                                   // Инициализирует последовательное соединение и задаём скорость передачи данных.
  delay(1000);                                          // Задержка 1000ms (1s)
  
  Serial.println("Демонстрация работы модуля DS3231:");
  
  if (!rtc.begin()) {                                   // Инициализация модуля DS3231, если модуль не найден.
    Serial.println("Ошибка: DS3231 не найден!");        // Вывод сообщения "Ошибка: DS3231 не найден!".
    while(1);                                           // Бесконечный цикл при ошибке.
  }
  
  Serial.println("Модуль DS3231 подключен!");           // Сообщение об успешном подключении.
  
  float temp = rtc.getTemperature();                    // Получаем температуру с модуля DS3231.
  if (temp > -100) {                                    // Если температура корректная.
    Serial.print("Температура DS3231: ");               // Вывод сообщения "Температура DS3231: "
    Serial.print(temp);                                 // Вывод значения температуры.
    Serial.println("°C");                               // Вывод единицы измерения "°C"
  }
  
  if (rtc.lostPower()) {                                // Проверяем, терял ли модуль питание.
    Serial.println("Внимание: DS3231 терял питание!");  // Вывод предупреждения о потере питания.
    Serial.println("Рекомендация: Настройте время.");   // Вывод рекомендации.
  }
  
  rtc.setDateTime(2025, 1, 1, 0, 0, 0);                 // Установите время один раз, затем закомментируйте.
}

void loop() {
  static uint32_t Timer = 0;                            // Объявление локальной переменной. (таймер-1)
  
  if (millis() - Timer >= 1000) {                       // Если отсчитанное время >= 1000 ms, тогда:
    Timer = millis();                                   // Сброс таймера-1.
    
    Serial.print("Дата и время: ");                     // Вывод сообщения "Дата и время"
    Serial.print(rtc.getDateTime());                    // Получаем и отправляем информацию о Дате и Времени. Пример: 01/01/2025 00:00:00
    
    Serial.print(" | Время с тиканием: ");              // Вывод сообщения " | Время с тиканием: "
    Serial.println(rtc.getTime(true));                  // Получаем и отправляем информацию Времени. Пример: 00:00 (00 00)
    
    static uint8_t Timer2 = 0;                          // Объявление локальной переменной. (таймер-2)
    if (++Timer2 >= 10) {                               // Каждые 10 секунд отправляем подробную информацию.
      Timer2 = 0;                                       // Сброс таймера-2.
      
      float currentTemp = rtc.getTemperature();         // Получаем текущую температуру.
      Serial.print("Температура: ");                    // Вывод сообщения "Температура: "
      Serial.print(currentTemp);                        // Вывод значения температуры.
      Serial.print("°C | ");                            // Вывод единицы измерения "°C | "
      
      Serial.print("Подробно: Год=");                   // Вывод сообщения "Подробно: Год="
      Serial.print(rtc.getYear());                      // Получаем и отправляем информацию "Год". Пример: 2025
      Serial.print(" Месяц=");                          // Вывод сообщения " Месяц="
      Serial.print(rtc.getMonth());                     // Получаем и отправляем информацию "Месяц". Пример: 1
      Serial.print(" День=");                           // Вывод сообщения " День="
      Serial.print(rtc.getDay());                       // Получаем и отправляем информацию "День". Пример: 1
      Serial.print(" Час=");                            // Вывод сообщения " Час="
      Serial.print(rtc.getHour());                      // Получаем и отправляем информацию "Час". Пример: 0
      Serial.print(" Минута=");                         // Вывод сообщения " Минута="
      Serial.print(rtc.getMinute());                    // Получаем и отправляем информацию "Минута". Пример: 0
      Serial.print(" Секунда=");                        // Вывод сообщения " Секунда="
      Serial.println(rtc.getSecond());                  // Получаем и отправляем информацию "Секунда". Пример: 0
    }
  }
}
```

### BOTC_RTC_PCF8563

```cpp
#include <BrgOfTheCyber_RTC.h>                          // Подключаем библиотеку для работы с внешними RTC модулями.
BrgOfTheCyber_RTC rtc(RTC_PCF8563, 0x51);               // Инициализация объекта для модуля PCF8563 с адресом 0x51

void setup() {
  Serial.begin(9600);                                   // Инициализирует последовательное соединение и задаём скорость передачи данных.
  delay(1000);                                          // Задержка 1000ms (1s)
  
  Serial.println("Демонстрация работы модуля PCF8563:");
  
  if (!rtc.begin()) {                                   // Инициализация модуля PCF8563, если модуль не найден.
    Serial.println("Ошибка: PCF8563 не найден!");       // Вывод сообщения "Ошибка: PCF8563 не найден!".
    Serial.println("Адрес I2C: 0x51 (обычно)");         // 
    while(1);                                           // Бесконечный цикл при ошибке.
  }
  
  Serial.println("Модуль PCF8563 подключен!");          // Сообщение об успешном подключении.
  
  rtc.setDateTime(2025, 1, 1, 0, 0, 0);                 // Установите время один раз, затем закомментируйте.
}

void loop() {
  static uint32_t Timer = 0;                            // Объявление локальной переменной. (таймер-1)
  
  if (millis() - Timer >= 1000) {                       // Если отсчитанное время >= 1000 ms, тогда:
    Timer = millis();                                   // Сброс таймера-1.
    
    Serial.print("Дата и время: ");                     // Вывод сообщения "Дата и время"
    Serial.print(rtc.getDateTime());                    // Получаем и отправляем информацию о Дате и Времени. Пример: 01/01/2025 00:00:00
    
    Serial.print(" | Время с тиканием: ");              // Вывод сообщения " | Время с тиканием: "
    Serial.println(rtc.getTime(true));                  // Получаем и отправляем информацию Времени. Пример: 00:00 (00 00)
    
    static uint8_t Timer2 = 0;                          // Объявление локальной переменной. (таймер-2)
    if (++Timer2 >= 10) {                               // Каждые 10 секунд отправляем подробную информацию.
      Timer2 = 0;                                       // Сброс таймера-2.
      
      // Создаем кастомный формат вывода
      Serial.print("Кастомный формат: ");               // Вывод сообщения "Кастомный формат: "
      Serial.print(rtc.getDay());                       // Получаем и отправляем информацию "День". Пример: 1
      Serial.print(".");                                // Вывод точки как разделителя
      Serial.print(rtc.getMonth());                     // Получаем и отправляем информацию "Месяц". Пример: 1
      Serial.print(".");                                // Вывод точки как разделителя
      Serial.print(rtc.getYear());                      // Получаем и отправляем информацию "Год". Пример: 2025
      Serial.print(" ");                                // Вывод пробела
      Serial.print(rtc.getHour());                      // Получаем и отправляем информацию "Час". Пример: 0
      Serial.print(":");                                // Вывод двоеточия как разделителя
      Serial.print(rtc.getMinute());                    // Получаем и отправляем информацию "Минута". Пример: 0
      Serial.print(":");                                // Вывод двоеточия как разделителя
      Serial.print(rtc.getSecond());                    // Получаем и отправляем информацию "Секунда". Пример: 0

      Serial.print("Формат ДД/ММ: ");                   // Вывод сообщения "Формат ДД/ММ: "
      Serial.print(rtc.getToDay());                     // Получаем и отправляем информацию в формате День/Месяц. Пример: 01/01
      Serial.print(" | Формат ДД/ММ/ГГГГ: ");           // Вывод сообщения " | Формат ДД/ММ/ГГГГ: "
      Serial.println(rtc.getDate());                    // Получаем и отправляем информацию в формате День/Месяц/Год. Пример: 01/01/2025

      Serial.print(" | Проверка работы: ");             // Вывод сообщения " | Проверка работы: "
      if (rtc.isRunning()) {                            // Проверяем, работает ли модуль
        Serial.println("Модуль работает корректно");    // Сообщение о корректной работе
      } else {
        Serial.println("Ошибка модуля!");               // Сообщение об ошибке
      }
    }
  }
}
```
### BOTC_RTC_Sys

```cpp
#include <BrgOfTheCyber_RTC_Sys.h>          // Подключаем библиотеку "BrgOfTheCyber_RTC_Sys.h" для работы системными часами МК.
BrgOfTheCyber_RTC_Sys rtc;                  // Инициализация объекта.

void setup() {
  Serial.begin(9600);                       // Инициализирует последовательное соединение и задаём скорость передачи данных.
  delay(1000);                              // Задержка 1000ms (1s).
  
  Serial.println("Демонстрация работы системных часов:");
  
  rtc.begin();                              // Инициализация.
  
  rtc.setDateTime(2025, 1, 1, 0, 0, 0);     // Установите время один раз, затем закомментируйте.
  // rtc.setDateTimeFromCompile();          // Или используйте время компиляции.
}

void loop() {
  static uint32_t Timer = 0;                // Объявление локальной переменной. (таймер-1)
  
  if (millis() - Timer >= 1000) {           // Если отсчитанное время >= 1000 ms, тогда:
    Timer = millis();                       // Сброс таймера-1.
    
    Serial.print("Дата и время: ");         // Вывод сообщения "Дата и время"
    Serial.print(rtc.getDateTime());        // Получаем и отправялем информацию о Дате и Времени. Пример: 01/01/2025 00:00:00
    
    Serial.print(" | Время с тиканием: ");  // Вывод сообщения " | Время с тиканием: "
    Serial.println(rtc.getTime(true));      // Получаем и отправялем информацию Времени. Пример: 00:00 (00 00)
    
    static uint8_t Timer2 = 0;              // Объявление локальной переменной. (таймер-2)
    if (++Timer2 >= 10) {                   // Каждые 10 секунд отправяем подробную информацию.
      Timer2 = 0;                           // Сброс таймера-2.
      Serial.print("Подробно: Год=");       // Вывод сообщения "Подробно: Год="
      Serial.print(rtc.getYear());          // Получаем и отправялем информацию "Год". Пример: 2025
      Serial.print(" Месяц=");              // Вывод сообщения " Месяц="
      Serial.print(rtc.getMonth());         // Получаем и отправялем информацию "Месяц". Пример: 1
      Serial.print(" День=");               // Вывод сообщения " День="
      Serial.print(rtc.getDay());           // Получаем и отправялем информацию "День". Пример: 1
      Serial.print(" Час=");                // Вывод сообщения " Час="
      Serial.print(rtc.getHour());          // Получаем и отправялем информацию "Час". Пример: 0
      Serial.print(" Минута=");             // Вывод сообщения " Минута="
      Serial.print(rtc.getMinute());        // Получаем и отправялем информацию "Минута". Пример: 0
      Serial.print(" Секунда=");            // Вывод сообщения " Секунда="
      Serial.println(rtc.getSecond());      // Получаем и отправялем информацию "Секунда". Пример: 0
    }
  }
}
```

<a id="versions"></a>

## Версии
- v1.0.0
- v1.1.2 - Добавление работы RTC, как с внешнем модулем, так и от самого МК

<a id="install"></a>

## Установка
- Библиотеку можно найти по названию **BrgOfTheCyber_RTC** и установить через менеджер библиотек в:
    - Arduino IDE
    - Arduino IDE v2
- [Скачать библиотеку](https://github.com/BOTCLibs/BrgOfTheCyber_RTC/archive/refs/heads/main.zip) .zip архивом для ручной установки:
    - Распаковать и положить в *C:\Program Files (x86)\Arduino\libraries* (Windows x64)
    - Распаковать и положить в *C:\Program Files\Arduino\libraries* (Windows x32)
    - Распаковать и положить в *Документы/Arduino/libraries/*
    - (Arduino IDE) автоматическая установка из .zip: *Скетч/Подключить библиотеку/Добавить .ZIP библиотеку…* и указать скачанный архив

### Обновление
- Рекомендую всегда обновлять библиотеку: в новых версиях исправляются ошибки и баги, а также проводится оптимизация и добавляются новые возможности.
- Через менеджер библиотек IDE: найти библиотеку как при установке и нажать "Обновить".
- Вручную: **удалить папку со старой версией**, а затем положить на её место новую. "Замену" делать нельзя: иногда в новых версиях удаляются файлы, которые останутся при замене и могут привести к ошибкам!

<a id="feedback"></a>

## Баги и обратная связь
При нахождении багов, лучше сразу пишите на почту [brgcraft@ya.ru](mailto:brgcraft@ya.ru)  
Библиотека открыта для доработки!

При сообщении о багах или некорректной работе библиотеки нужно обязательно указывать:
- Версия Arduino IDE.
- Версия библиотеки.
- Какой используется Микроконтроллер или версия SDK, если у Вас ESP.
- Корректно ли работают ли встроенные примеры, в которых используются функции и конструкции, приводящие к багу в вашем коде.
- Если Вы создавали свой код, с использованием данной библиотеки, тогда опишите: какой код загружался, что ожидалось, что на выходе получилось.
- Желательно, приложите минимальный код, в котором наблюдается баг.